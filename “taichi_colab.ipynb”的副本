{"cells":[{"cell_type":"markdown","metadata":{"id":"fXU98l7F06XK"},"source":["## Using [Taichi](http://taichi.graphics/) on Colab kernels"]},{"cell_type":"code","execution_count":1,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":629,"status":"ok","timestamp":1654194739345,"user":{"displayName":"Everyone is a mathematician","userId":"10191155237595623249"},"user_tz":-480},"id":"8emHrkFgGtRg","outputId":"1a2a9bdd-576e-405b-a95a-b69d029e2f7a"},"outputs":[{"name":"stdout","output_type":"stream","text":["Kernel is Taichi-ready!\n"]}],"source":["# Taichi crash on Colab workaround (see https://github.com/taichi-dev/taichi/issues/235)\n","\n","import os, json, signal, time\n","if 'libtcmalloc' in os.environ.get('LD_PRELOAD', ''):\n","  kernel_fn = '/usr/local/share/jupyter/kernels/python3/kernel.json'\n","  spec = json.load(open(kernel_fn))\n","  spec['env'] = {'LD_PRELOAD': ''}\n","  json.dump(spec, open(kernel_fn, 'w'))\n","  print(\"Installed Taichi workaround. Don't wait for this cell to finish,\")\n","  print('just REFRESH the browser tab and RUN this cell again.', flush=True)\n","  time.sleep(0.5)\n","  # killing the kernel manager so that specs get reloaded\n","  os.kill(os.getppid(), signal.SIGTERM)\n","else:\n","  print('Kernel is Taichi-ready!')\n"]},{"cell_type":"code","execution_count":2,"metadata":{"executionInfo":{"elapsed":745,"status":"ok","timestamp":1654194744054,"user":{"displayName":"Everyone is a mathematician","userId":"10191155237595623249"},"user_tz":-480},"id":"uuYuj4v-Fqpy"},"outputs":[],"source":["#@title imports \u0026 utils\n","import os\n","import io\n","import PIL.Image, PIL.ImageDraw\n","import base64\n","import numpy as np\n","import matplotlib.pylab as pl\n","\n","from IPython.display import Image, HTML, clear_output\n","import tqdm\n","\n","import os\n","os.environ['FFMPEG_BINARY'] = 'ffmpeg'\n","import moviepy.editor as mvp\n","from moviepy.video.io.ffmpeg_writer import FFMPEG_VideoWriter\n","clear_output()\n","\n","def np2pil(a):\n","  if a.dtype in [np.float32, np.float64]:\n","    a = np.uint8(np.clip(a, 0, 1)*255)\n","  return PIL.Image.fromarray(a)\n","\n","def imwrite(f, a, fmt=None):\n","  a = np.asarray(a)\n","  if isinstance(f, str):\n","    fmt = f.rsplit('.', 1)[-1].lower()\n","    if fmt == 'jpg':\n","      fmt = 'jpeg'\n","    f = open(f, 'wb')\n","  np2pil(a).save(f, fmt, quality=95)\n","\n","def imencode(a, fmt='jpeg'):\n","  a = np.asarray(a)\n","  if len(a.shape) == 3 and a.shape[-1] == 4:\n","    fmt = 'png'\n","  f = io.BytesIO()\n","  imwrite(f, a, fmt)\n","  return f.getvalue()\n","\n","def im2url(a, fmt='jpeg'):\n","  encoded = imencode(a, fmt)\n","  base64_byte_string = base64.b64encode(encoded).decode('ascii')\n","  return 'data:image/' + fmt.upper() + ';base64,' + base64_byte_string\n","\n","def imshow(a, fmt='jpeg'):\n","  display(Image(data=imencode(a, fmt)))\n","\n","\n","class VideoWriter:\n","  def __init__(self, filename, fps=30.0, **kw):\n","    self.writer = None\n","    self.params = dict(filename=filename, fps=fps, **kw)\n","\n","  def add(self, img):\n","    img = np.asarray(img)\n","    if self.writer is None:\n","      h, w = img.shape[:2]\n","      self.writer = FFMPEG_VideoWriter(size=(w, h), **self.params)\n","    if img.dtype in [np.float32, np.float64]:\n","      img = np.uint8(img.clip(0, 1)*255)\n","    if len(img.shape) == 2:\n","      img = np.repeat(img[..., None], 3, -1)\n","    self.writer.write_frame(img)\n","\n","  def close(self):\n","    if self.writer:\n","      self.writer.close()\n","\n","  def __enter__(self):\n","    return self\n","\n","  def __exit__(self, *kw):\n","    self.close()"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"nQvh0pgDmTGO","outputId":"3195037d-a558-406b-8880-9894cb102d00"},"outputs":[{"name":"stdout","output_type":"stream","text":["Looking in indexes: https://pypi.org/simple, https://us-python.pkg.dev/colab-wheels/public/simple/\n","Collecting taichi-nightly-cuda-10-1==0.5.2\n"]}],"source":["!pip install taichi-nightly-cuda-10-1==0.5.2"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"background_save":true},"id":"WK0yoYP0Diuv"},"outputs":[{"name":"stdout","output_type":"stream","text":["[Release mode]\n","[Taichi version 0.5.2, cuda 10.1, commit 4d56959a]\n"]}],"source":["# from 'mpm88.py'\n","\n","import taichi as ti\n","import random\n","\n","ti.reset()\n","\n","ti.init(arch=ti.cuda)\n","\n","dim = 2\n","n_particles = 8192\n","n_grid = 128\n","dx = 1 / n_grid\n","inv_dx = 1 / dx\n","dt = 2.0e-4\n","p_vol = (dx * 0.5)**2\n","p_rho = 1\n","p_mass = p_vol * p_rho\n","E = 400\n","img_size = 512\n","\n","x = ti.Vector(dim, dt=ti.f32, shape=n_particles)\n","v = ti.Vector(dim, dt=ti.f32, shape=n_particles)\n","C = ti.Matrix(dim, dim, dt=ti.f32, shape=n_particles)\n","J = ti.var(dt=ti.f32, shape=n_particles)\n","grid_v = ti.Vector(dim, dt=ti.f32, shape=(n_grid, n_grid))\n","grid_m = ti.var(dt=ti.f32, shape=(n_grid, n_grid))\n","grid_img = ti.Vector(3, dt=ti.f32, shape=(img_size, img_size))\n","\n","@ti.kernel\n","def substep():\n","  for p in x:\n","    base = (x[p] * inv_dx - 0.5).cast(int)\n","    fx = x[p] * inv_dx - base.cast(float)\n","    w = [0.5 * ti.sqr(1.5 - fx), 0.75 - ti.sqr(fx - 1), 0.5 * ti.sqr(fx - 0.5)]\n","    stress = -dt * p_vol * (J[p] - 1) * 4 * inv_dx * inv_dx * E\n","    affine = ti.Matrix([[stress, 0], [0, stress]]) + p_mass * C[p]\n","    for i in ti.static(range(3)):\n","      for j in ti.static(range(3)):\n","        offset = ti.Vector([i, j])\n","        dpos = (offset.cast(float) - fx) * dx\n","        weight = w[i][0] * w[j][1]\n","        grid_v[base + offset].atomic_add(\n","            weight * (p_mass * v[p] + affine @ dpos))\n","        grid_m[base + offset].atomic_add(weight * p_mass)\n","\n","  for i, j in grid_m:\n","    if grid_m[i, j] \u003e 0:\n","      bound = 3\n","      inv_m = 1 / grid_m[i, j]\n","      grid_v[i, j] = inv_m * grid_v[i, j]\n","      grid_v[i, j][1] -= dt * 9.8\n","      if i \u003c bound and grid_v[i, j][0] \u003c 0:\n","        grid_v[i, j][0] = 0\n","      if i \u003e n_grid - bound and grid_v[i, j][0] \u003e 0:\n","        grid_v[i, j][0] = 0\n","      if j \u003c bound and grid_v[i, j][1] \u003c 0:\n","        grid_v[i, j][1] = 0\n","      if j \u003e n_grid - bound and grid_v[i, j][1] \u003e 0:\n","        grid_v[i, j][1] = 0\n","\n","  for p in x:\n","    base = (x[p] * inv_dx - 0.5).cast(int)\n","    fx = x[p] * inv_dx - base.cast(float)\n","    w = [\n","        0.5 * ti.sqr(1.5 - fx), 0.75 - ti.sqr(fx - 1.0), 0.5 * ti.sqr(fx - 0.5)\n","    ]\n","    new_v = ti.Vector.zero(ti.f32, 2)\n","    new_C = ti.Matrix.zero(ti.f32, 2, 2)\n","    for i in ti.static(range(3)):\n","      for j in ti.static(range(3)):\n","        dpos = ti.Vector([i, j]).cast(float) - fx\n","        g_v = grid_v[base + ti.Vector([i, j])]\n","        weight = w[i][0] * w[j][1]\n","        new_v += weight * g_v\n","        new_C += 4 * weight * ti.outer_product(g_v, dpos) * inv_dx\n","    v[p] = new_v\n","    x[p] += dt * v[p]\n","    J[p] *= 1 + dt * new_C.trace()\n","    C[p] = new_C\n","\n","    # draw\n","    xi = (x[p] * img_size).cast(int)\n","    grid_img[xi] += ti.Vector([1.0, 1.0, 1.0])\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"pEsqVKCXCpfV"},"outputs":[],"source":["import PIL.Image, PIL.ImageFont, PIL.ImageDraw\n","\n","def gen_points(s, font_size=42):\n","  font = PIL.ImageFont.truetype('/usr/share/fonts/truetype/liberation/LiberationMono-Bold.ttf', font_size)\n","  w, h = font.getsize(s)\n","  im = PIL.Image.new('L', (w, h))\n","  draw  = PIL.ImageDraw.Draw(im)\n","  draw.text((0, 0), s, fill=255, font=font)\n","  im = np.uint8(im)\n","  y, x = np.float32(im.nonzero())\n","  pos = np.column_stack([x, y]) / w\n","  return pos\n","\n","pos = np.vstack([\n","  gen_points(' Taichi ', 100)+(0.0, 0.1),\n","  gen_points('   +   ', 100)+(0.0, 0.3),\n","  gen_points(' Colab ', 100)+(0.0, 0.5),\n","])\n","pos[:,1] = 1.0-pos[:,1]\n","np.random.shuffle(pos)\n","pos = pos[:n_particles]\n","\n","for i in range(n_particles):\n","  x[i] = pos[i]\n","  v[i] = [0, 0]\n","  J[i] = 1\n","\n","\n","\n","with VideoWriter('mpm88.mp4', 60) as vid:\n","  frames = []\n","  for frame in tqdm.trange(60*5):\n","    grid_img.fill([0, 0, 0])\n","    for s in range(20):\n","      grid_v.fill([0, 0])\n","      grid_m.fill(0)\n","      substep()\n","    vis = grid_img.to_numpy()[...,0]/20\n","    vis **= 1/2.2  # gamma correction\n","    vis = vis.swapaxes(0, 1)[::-1]\n","    frames.append(vis)\n","    vid.add(vis)\n","\n","  for vis in tqdm.tqdm(frames[::-1]):\n","    vid.add(vis)\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"djFkrAwKHEZH"},"outputs":[],"source":["mvp.ipython_display('mpm88.mp4', loop=True)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"ErKnkKZIvRZO"},"outputs":[],"source":[""]}],"metadata":{"accelerator":"GPU","colab":{"collapsed_sections":[],"name":"“taichi_colab.ipynb”的副本","provenance":[{"file_id":"https://github.com/znah/notebooks/blob/master/taichi_colab.ipynb","timestamp":1654194544639}],"toc_visible":true,"version":""},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}